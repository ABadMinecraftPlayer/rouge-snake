<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roguelite Snake</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #f0f0f0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            touch-action: manipulation; /* Disable double-tap zoom on mobile */
        }
        canvas {
            background-color: #111;
            border: 4px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        
        /* UI Panels */
        .ui-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(20, 20, 20, 0.95);
            border: 4px solid #444;
            border-radius: 12px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .hidden {
            display: none;
        }

        /* Buttons */
        .btn {
            display: inline-block;
            background-color: #2a2a2a;
            border: 2px solid #555;
            color: #00ff00;
            padding: 1rem 1.5rem;
            margin-top: 1rem;
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px #00a000;
        }
        
        .btn:hover {
            background-color: #333;
            border-color: #777;
            transform: translateY(-2px);
            box-shadow: 0 6px #00c000;
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px #008000;
        }

        .btn-secondary {
            background-color: #331111;
            border-color: #772222;
            color: #ff4444;
            box-shadow: 0 4px #a00000;
        }
        
        .btn-secondary:hover {
            background-color: #441111;
            border-color: #992222;
            box-shadow: 0 6px #c00000;
        }
        
        .btn-secondary:active {
            box-shadow: 0 2px #800000;
        }
        
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            margin-left: 1rem;
        }

        /* Upgrade Item */
        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #222;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 2px solid #333;
            text-align: left;
        }
        
        .upgrade-info {
            flex-grow: 1;
        }
        
        .upgrade-info p {
            font-size: 0.8rem;
            margin: 0.25rem 0;
        }
        
        .upgrade-info .cost {
            color: #ffff00;
            font-weight: bold;
        }

        /* Checkbox Toggle */
        .toggle-label {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
            margin-right: 10px;
        }

        .toggle-label input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 28px;
            border: 2px solid #555;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #aaa;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00a000;
            border-color: #00ff00;
        }

        input:checked + .slider:before {
            transform: translateX(22px);
            background-color: #fff;
        }

        /* Game HUD */
        #game-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
            background: rgba(0,0,0,0.5);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            color: #ffff00;
            font-size: 1.1rem;
            z-index: 5;
            min-width: 300px;
            text-align: center;
        }

        #touch-controls {
            position: absolute;
            bottom: 20px;
            width: 150px;
            height: 150px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            z-index: 20;
        }
        
        .touch-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            opacity: 0.7;
        }
        
        #touch-up { grid-column: 2; grid-row: 1; }
        #touch-left { grid-column: 1; grid-row: 2; }
        #touch-right { grid-column: 3; grid-row: 2; }
        #touch-down { grid-column: 2; grid-row: 3; }
        
        /* Card Choice UI */
        .card {
            background-color: #2a2a2a;
            border: 2px solid #555;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px #444;
        }
        
        .card:hover {
            background-color: #333;
            border-color: #00ff00;
            transform: translateY(-4px);
            box-shadow: 0 8px #00a000;
        }
        
        .card h3 {
            font-size: 1.25rem;
            color: #00ff00;
            margin-bottom: 0.5rem;
        }
        
        .card .buff {
            color: #f0f0f0;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .card .debuff {
            color: #ff4444;
            font-size: 0.8rem;
        }
        
        @media (min-width: 768px) {
            #touch-controls {
                display: none; /* Hide touch controls on larger screens */
            }
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <div id="game-container" class="relative">
        <div id="game-hud" class="hidden">
            <div id="lives-display">LIVES: 3</div>
            <div id="score-display">SCORE: 0</div>
            <div id="quota-display">QUOTA: 5</div>
            <div id="round-display">ROUND: 1</div>
            <div id="coins-display">COINS: 0</div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Main Menu UI -->
    <div id="main-menu" class="ui-panel">
        <h1 class="text-3xl text-green-400 mb-4">Roguelite Snake</h1>
        <p class="text-lg mb-2">Total Applecoins: <span id="menu-coins" class="text-yellow-300">0</span></p>
        <p class="text-base mb-6">Highest Round: <span id="menu-high-round" class="text-yellow-300">0</span></p>
        <button id="start-game-btn" class="btn w-full">Start Game</button>
        <button id="upgrades-btn" class="btn w-full">Upgrades</button>
    </div>

    <!-- Game Over UI -->
    <div id="game-over-menu" class="ui-panel hidden">
        <h1 class="text-3xl text-red-500 mb-4">GAME OVER</h1>
        <p class="text-lg mb-2">Final Score: <span id="final-score" class="text-white">0</span></p>
        <p class="text-lg mb-2">Rounds Reached: <span id="final-round" class="text-white">0</span></p>
        <p class="text-lg mb-6">Applecoins Earned: <span id="coins-earned" class="text-yellow-300">0</span></p>
        <button id="restart-btn" class="btn w-full">Main Menu</button>
    </div>

    <!-- Card Choice UI -->
    <div id="card-choice-menu" class="ui-panel hidden">
        <h1 class="text-2xl text-yellow-300 mb-4">CHOOSE A BOOSTER</h1>
        <div id="card-options">
            <!-- Cards will be injected here by JS -->
        </div>
    </div>

    <!-- Upgrades UI -->
    <div id="upgrades-menu" class="ui-panel hidden">
        <h1 class="text-2xl text-yellow-300 mb-4">UPGRADES</h1>
        <p class="text-lg mb-6">Available Coins: <span id="upgrade-coins" class="text-yellow-300">0</span></p>
        
        <!-- Upgrade Item 1: Apple Spawn Rate -->
        <div class="upgrade-item">
            <div class="upgrade-info">
                <p class="text-green-400">Apple Abundance</p>
                <p>Increases apple spawn rate.</p>
                <p>Current: <span id="apple-rate-value">2.00%</span></p>
                <p class="cost">Cost: <span id="apple-rate-cost">10</span> Coins</p>
            </div>
            <div>
                <button id="buy-apple-rate" class="btn btn-small">Buy</button>
            </div>
        </div>
        
        <!-- Upgrade Item 2: Starting Length (Example) -->
        <div class="upgrade-item">
            <div class="upgrade-info">
                <p class="text-blue-400">Long Start</p>
                <p>Start with a longer snake.</p>
                <p>Current: <span id="start-length-value">3</span></p>
                <p class="cost">Cost: <span id="start-length-cost">25</span> Coins</p>
            </div>
            <div>
                <button id="buy-start-length" class="btn btn-small">Buy</button>
            </div>
        </div>

        <h2 class="text-xl text-gray-400 mt-8 mb-4">Toggle Upgrades</h2>
        <div class="upgrade-item">
            <label class="toggle-label">
                <input type="checkbox" id="toggle-apple-rate">
                <span class="slider"></span>
            </label>
            <span class="text-sm">Apple Abundance (Active)</span>
        </div>
        <div class="upgrade-item">
            <label class="toggle-label">
                <input type="checkbox" id="toggle-start-length">
                <span class="slider"></span>
            </label>
            <span class="text-sm">Long Start (Active)</span>
        </div>

        <button id="back-to-menu-btn" class="btn btn-secondary w-full mt-8">Back to Menu</button>
    </div>
    
    <!-- Touch Controls for Mobile -->
    <div id="touch-controls" class="hidden">
        <button id="touch-up" class="touch-btn">▲</button>
        <button id="touch-left" class="touch-btn">◄</button>
        <button id="touch-right" class="touch-btn">►</button>
        <button id="touch-down" class="touch-btn">▼</button>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Game Constants ---
            const GRID_SIZE = 20; // 20x20 grid
            let TILE_SIZE = 20;   // Size of each tile in pixels

            // --- Game Elements ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // UI Panels
            const mainMenu = document.getElementById('main-menu');
            const gameOverMenu = document.getElementById('game-over-menu');
            const upgradesMenu = document.getElementById('upgrades-menu');
            const gameHud = document.getElementById('game-hud');
            const touchControls = document.getElementById('touch-controls');

            // UI Buttons
            const startGameBtn = document.getElementById('start-game-btn');
            const upgradesBtn = document.getElementById('upgrades-btn');
            const restartBtn = document.getElementById('restart-btn');
            const backToMenuBtn = document.getElementById('back-to-menu-btn');
            const buyAppleRateBtn = document.getElementById('buy-apple-rate');
            const buyStartLengthBtn = document.getElementById('buy-start-length');
            
            // UI Toggles
            const toggleAppleRate = document.getElementById('toggle-apple-rate');
            const toggleStartLength = document.getElementById('toggle-start-length');

            // UI Readouts
            const menuCoins = document.getElementById('menu-coins');
            const upgradeCoins = document.getElementById('upgrade-coins');
            const finalScore = document.getElementById('final-score');
            const coinsEarned = document.getElementById('coins-earned');
            const scoreDisplay = document.getElementById('score-display');
            const coinsDisplay = document.getElementById('coins-display');
            const livesDisplay = document.getElementById('lives-display');
            const roundDisplay = document.getElementById('round-display');
            const quotaDisplay = document.getElementById('quota-display');
            const menuHighRound = document.getElementById('menu-high-round');
            const finalRound = document.getElementById('final-round');
            
            // Card UI
            const cardChoiceMenu = document.getElementById('card-choice-menu');
            const cardOptions = document.getElementById('card-options');
            
            // Upgrade Readouts
            const appleRateValue = document.getElementById('apple-rate-value');
            const appleRateCost = document.getElementById('apple-rate-cost');
            const startLengthValue = document.getElementById('start-length-value');
            const startLengthCost = document.getElementById('start-length-cost');

            // --- Game State ---
            let gameState = 'MENU'; // MENU, GAME, UPGRADES, GAME_OVER, CARD_CHOICE
            let snake, apples, obstacles, direction, newDirection, score, gameLoopInterval;
            let lives, roundCounter, scoreQuota, currentGridSize;
            let activeBuffs = {};
            let generatedCards = [];
            let gameSpeed = 100; // Lowered from 120ms for responsiveness

            // --- Persistent Roguelite State ---
            let persistentState = {
                appleCoins: 0,
                highestRound: 0,
                upgrades: {
                    appleSpawnRateLevel: 0, // Each level adds 0.25%
                    startLengthLevel: 0     // Each level adds 1
                },
                activeUpgrades: {
                    appleSpawnRate: true,
                    startLength: true
                }
            };
            
            const BASE_APPLE_SPAWN_RATE = 0.02; // 2%
            const APPLE_RATE_INCREASE = 0.0025; // +0.25% per level
            const BASE_START_LENGTH = 3;
            const START_LENGTH_INCREASE = 1;

            // --- Card Database ---
            const cardDatabase = [
                {
                    id: "EXTRA_LIFE",
                    title: "+1 Life",
                    buff: "Gain an extra life.",
                    debuff: null,
                    applyEffect: () => { 
                        lives++; 
                        updateHud(); 
                    }
                },
                {
                    id: "APPLE_BOOM",
                    title: "Apple Boom",
                    buff: "Instantly spawns 3 extra apples.",
                    debuff: null,
                    applyEffect: () => {
                        spawnSingleApple();
                        spawnSingleApple();
                        spawnSingleApple();
                    }
                },
                {
                    id: "TAIL_TRIM",
                    title: "Quick Trim",
                    buff: "Lose 5 tail segments.",
                    debuff: "A bit shorter, but easier to move!",
                    applyEffect: () => {
                        while(snake.length > BASE_START_LENGTH && snake.length > 5) {
                            snake.pop();
                        }
                    }
                },
                {
                    id: "HASTY",
                    title: "Hasty",
                    buff: "Move 20% faster.",
                    debuff: "Get +1 Applecoin per 2 apples next round.",
                    applyEffect: () => {
                        gameSpeed = 80; // Faster (80ms tick)
                        activeBuffs.hasty = true;
                    }
                },
                {
                    id: "GHOST",
                    title: "Ghost Form",
                    buff: "Pass through your own tail for 10 seconds.",
                    debuff: null,
                    applyEffect: () => {
                        activeBuffs.ghost = 100; // 100 ticks (10 seconds)
                    }
                },
                {
                    id: "COIN_BONUS",
                    title: "Investment",
                    buff: "Instantly gain 10 Applecoins.",
                    debuff: null,
                    applyEffect: () => {
                        persistentState.appleCoins += 10;
                        updateHud();
                        saveState();
                    }
                }
            ];

            // --- Game Logic ---

            function initializeGame() {
                loadState();
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // Keyboard Input
                document.addEventListener('keydown', e => {
                    if (gameState !== 'GAME') return;
                    
                    const key = e.key;
                    if ((key === 'ArrowUp' || key === 'w') && direction.y === 0) {
                        newDirection = { x: 0, y: -1 };
                    } else if ((key === 'ArrowDown' || key === 's') && direction.y === 0) {
                        newDirection = { x: 0, y: 1 };
                    } else if ((key === 'ArrowLeft' || key === 'a') && direction.x === 0) {
                        newDirection = { x: -1, y: 0 };
                    } else if ((key === 'ArrowRight' || key === 'd') && direction.x === 0) {
                        newDirection = { x: 1, y: 0 };
                    }
                });
                
                // Touch Input
                document.getElementById('touch-up').addEventListener('click', () => {
                    if (gameState === 'GAME' && direction.y === 0) newDirection = { x: 0, y: -1 };
                });
                document.getElementById('touch-down').addEventListener('click', () => {
                    if (gameState === 'GAME' && direction.y === 0) newDirection = { x: 0, y: 1 };
                });
                document.getElementById('touch-left').addEventListener('click', () => {
                    if (gameState === 'GAME' && direction.x === 0) newDirection = { x: -1, y: 0 };
                });
                document.getElementById('touch-right').addEventListener('click', () => {
                    if (gameState === 'GAME' && direction.x === 0) newDirection = { x: 1, y: 0 };
                });

                // UI Button Listeners
                startGameBtn.addEventListener('click', startGame);
                upgradesBtn.addEventListener('click', showUpgradesMenu);
                restartBtn.addEventListener('click', showMainMenu);
                backToMenuBtn.addEventListener('click', showMainMenu);
                
                // Buy Listeners
                buyAppleRateBtn.addEventListener('click', () => buyUpgrade('appleSpawnRateLevel'));
                buyStartLengthBtn.addEventListener('click', () => buyUpgrade('startLengthLevel'));
                
                // Toggle Listeners
                toggleAppleRate.addEventListener('change', () => toggleUpgradeActive('appleSpawnRate'));
                toggleStartLength.addEventListener('change', () => toggleUpgradeActive('startLength'));

                showMainMenu();
            }

            function resizeCanvas() {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Leave some space for padding/UI
                const size = Math.min(viewportWidth, viewportHeight) * 0.9;
                
                TILE_SIZE = Math.floor(size / GRID_SIZE);
                canvas.width = TILE_SIZE * GRID_SIZE;
                canvas.height = TILE_SIZE * GRID_SIZE;
            }

            function updateUIState() {
                // Hide all panels first
                mainMenu.classList.add('hidden');
                gameOverMenu.classList.add('hidden');
                upgradesMenu.classList.add('hidden');
                gameHud.classList.add('hidden');
                touchControls.classList.add('hidden');
                cardChoiceMenu.classList.add('hidden');

                // Show the current panel
                if (gameState === 'MENU') {
                    mainMenu.classList.remove('hidden');
                    menuCoins.textContent = persistentState.appleCoins;
                    menuHighRound.textContent = persistentState.highestRound;
                } else if (gameState === 'GAME') {
                    gameHud.classList.remove('hidden');
                    touchControls.classList.remove('hidden');
                } else if (gameState === 'GAME_OVER') {
                    gameOverMenu.classList.remove('hidden');
                } else if (gameState === 'UPGRADES') {
                    upgradesMenu.classList.remove('hidden');
                    updateUpgradesUI();
                } else if (gameState === 'CARD_CHOICE') {
                    cardChoiceMenu.classList.remove('hidden');
                    displayCardChoices();
                }
            }
            
            function showMainMenu() {
                gameState = 'MENU';
                updateUIState();
                drawMenuBackground();
            }
            
            function showUpgradesMenu() {
                gameState = 'UPGRADES';
                updateUIState();
            }
            
            function drawMenuBackground() {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#222';
                for(let i = 0; i < GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * TILE_SIZE, 0);
                    ctx.lineTo(i * TILE_SIZE, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * TILE_SIZE);
                    ctx.lineTo(canvas.width, i * TILE_SIZE);
                    ctx.stroke();
                }
                ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.font = `${TILE_SIZE * 2}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText('SNAKE', canvas.width / 2, canvas.height / 2);
            }

            function startGame() {
                // 1. Initialize run state
                lives = 3;
                score = 0;
                roundCounter = 1;
                currentGridSize = GRID_SIZE; // Use constant GRID_SIZE as base
                scoreQuota = 5;
                activeBuffs = {};
                gameSpeed = 100;

                // 2. Change UI and setup first level
                gameState = 'GAME';
                setupLevel();
            }
            
            function setupLevel() {
                // 1. Get starting length from upgrades
                const startLength = persistentState.activeUpgrades.startLength
                    ? BASE_START_LENGTH + (persistentState.upgrades.startLengthLevel * START_LENGTH_INCREASE)
                    : BASE_START_LENGTH;

                // 2. Initialize level state
                snake = [];
                const spawnPoint = { x: Math.floor(currentGridSize / 2), y: Math.floor(currentGridSize / 2) };
                for (let i = 0; i < startLength; i++) {
                    snake.push({ x: spawnPoint.x - i, y: spawnPoint.y });
                }
                
                direction = { x: 1, y: 0 };
                newDirection = { x: 1, y: 0 };
                apples = [];
                obstacles = [];
                
                updateHud();

                // 3. Generate map and food
                generateProceduralMap(spawnPoint);
                spawnInitialApples();

                // 4. Change UI and start loop
                updateUIState();

                if (gameLoopInterval) clearInterval(gameLoopInterval);
                gameLoopInterval = setInterval(gameLoop, gameSpeed);
            }

            function gameLoop() {
                update();
                draw();
            }

            function update() {
                // Update active buffs
                if (activeBuffs.ghost > 0) {
                    activeBuffs.ghost--;
                    if (activeBuffs.ghost === 0) {
                        // Ghost effect wears off
                    }
                }
                
                direction = newDirection;
                const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

                // --- Check Collisions ---
                
                // Self-collision
                if (activeBuffs.ghost <= 0) { // Only check if not a ghost
                    for (let i = 1; i < snake.length; i++) {
                        if (head.x === snake[i].x && head.y === snake[i].y) {
                            return handleDeath();
                        }
                    }
                }
                
                // Obstacle collision
                if (obstacles.some(o => o.x === head.x && o.y === head.y)) {
                    return handleDeath();
                }

                snake.unshift(head); // Add new head

                // --- Check Apple Eat ---
                let ateApple = false;
                const appleIndex = apples.findIndex(a => a.x === head.x && a.y === head.y);
                
                if (appleIndex > -1) {
                    ateApple = true;
                    score++;
                    apples.splice(appleIndex, 1); // Remove eaten apple
                    spawnSingleApple(); // Spawn a new one
                    updateHud();
                    
                    // Check for max size bonus
                    const maxTiles = (currentGridSize * currentGridSize) - obstacles.length;
                    if(snake.length >= maxTiles) {
                        persistentState.appleCoins += 50; // Bonus!
                        saveState();
                        handleLevelWin();
                    }
                    // Check for score quota
                    else if (score >= scoreQuota) {
                        handleLevelWin();
                    }
                }

                if (!ateApple) {
                    snake.pop(); // Remove tail
                }
            }

            function draw() {
                // Clear canvas
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw obstacles
                ctx.fillStyle = '#444';
                obstacles.forEach(o => {
                    ctx.fillRect(o.x * TILE_SIZE, o.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
                });

                // Draw apples
                ctx.fillStyle = '#ff0000'; // Red
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(255, 0, 0, 0.7)";
                apples.forEach(a => {
                    ctx.fillRect(a.x * TILE_SIZE, a.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
                });
                ctx.shadowBlur = 0; // Reset shadow

                // Draw snake
                ctx.fillStyle = '#00ff00'; // Green
                if (activeBuffs.ghost > 0) {
                    ctx.globalAlpha = 0.6; // Ghost effect
                }
                snake.forEach((segment, index) => {
                    // Head is slightly brighter
                    ctx.fillStyle = index === 0 ? '#55ff55' : '#00ff00';
                    ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
                });
                ctx.globalAlpha = 1.0; // Reset alpha
            }
            
            function updateHud() {
                scoreDisplay.textContent = `SCORE: ${score}`;
                coinsDisplay.textContent = `COINS: ${persistentState.appleCoins}`;
                livesDisplay.textContent = `LIVES: ${lives}`;
                roundDisplay.textContent = `ROUND: ${roundCounter}`;
                quotaDisplay.textContent = `QUOTA: ${scoreQuota}`;
            }

            function handleDeath() {
                lives--;
                updateHud();
                clearInterval(gameLoopInterval);

                if (lives <= 0) {
                    triggerGameOver();
                } else {
                    // Lost a life, but not game over
                    // Flash screen red
                    canvas.style.backgroundColor = '#550000';
                    
                    // Reset snake position and length
                    const startLength = persistentState.activeUpgrades.startLength
                        ? BASE_START_LENGTH + (persistentState.upgrades.startLengthLevel * START_LENGTH_INCREASE)
                        : BASE_START_LENGTH;
                    
                    snake = [];
                    const spawnPoint = { x: Math.floor(currentGridSize / 2), y: Math.floor(currentGridSize / 2) };
                    for (let i = 0; i < startLength; i++) {
                        snake.push({ x: spawnPoint.x - i, y: spawnPoint.y });
                    }
                    // Penalty: lose some length
                    for(let i = 0; i < 5 && snake.length > startLength; i++) {
                        snake.pop();
                    }
                    
                    direction = { x: 1, y: 0 };
                    newDirection = { x: 1, y: 0 };

                    setTimeout(() => {
                        canvas.style.backgroundColor = '#111';
                        gameLoopInterval = setInterval(gameLoop, gameSpeed);
                    }, 1000);
                }
            }
            
            function handleLevelWin() {
                clearInterval(gameLoopInterval);
                gameState = 'CARD_CHOICE';
                generatedCards = generateBoosterCards();
                updateUIState();
            }

            function triggerGameOver() {
                clearInterval(gameLoopInterval);
                gameState = 'GAME_OVER';
                
                let earned = Math.floor(score / 2); // Simple formula: 1 coin per 2 apples
                if (activeBuffs.hasty) {
                    earned += Math.floor(score / 2); // Double coins
                }
                
                persistentState.appleCoins += earned;
                
                if (roundCounter > persistentState.highestRound) {
                    persistentState.highestRound = roundCounter;
                }
                
                saveState();
                
                finalScore.textContent = score;
                finalRound.textContent = roundCounter;
                coinsEarned.textContent = earned;
                
                updateUIState();
            }

            // --- Map & Food Generation ---
            
            function generateProceduralMap(spawnPoint) {
                obstacles = [];
                // Add border walls
                for (let i = 0; i < currentGridSize; i++) {
                    obstacles.push({ x: i, y: 0 });          // Top
                    obstacles.push({ x: i, y: currentGridSize - 1 }); // Bottom
                    obstacles.push({ x: 0, y: i });          // Left
                    obstacles.push({ x: currentGridSize - 1, y: i }); // Right
                }
                
                // Add some random internal rocks
                const numRocks = Math.floor(currentGridSize * 0.5);
                for(let i = 0; i < numRocks; i++) {
                    let pos = getRandomEmptyPosition();
                    // Avoid spawning near snake start
                    if (pos && (Math.abs(pos.x - spawnPoint.x) > 4 || Math.abs(pos.y - spawnPoint.y) > 4)) {
                        obstacles.push(pos);
                    }
                }
            }

            function spawnInitialApples() {
                apples = [];
                const spawnRate = persistentState.activeUpgrades.appleSpawnRate 
                    ? BASE_APPLE_SPAWN_RATE + (persistentState.upgrades.appleSpawnRateLevel * APPLE_RATE_INCREASE)
                    : BASE_APPLE_SPAWN_RATE;

                const numApples = Math.floor((currentGridSize * currentGridSize) * spawnRate);
                
                for(let i = 0; i < numApples; i++) {
                    spawnSingleApple();
                }
            }
            
            function spawnSingleApple() {
                let pos = getRandomEmptyPosition();
                if (pos) {
                    apples.push(pos);
                }
            }
            
            function getRandomEmptyPosition() {
                let pos;
                let attempts = 0;
                const maxAttempts = currentGridSize * currentGridSize;

                while (attempts < maxAttempts) {
                    pos = {
                        x: Math.floor(Math.random() * (currentGridSize - 2)) + 1, // Avoid borders
                        y: Math.floor(Math.random() * (currentGridSize - 2)) + 1
                    };
                    
                    if (isPositionEmpty(pos)) {
                        return pos;
                    }
                    attempts++;
                }
                return null; // No empty space found
            }
            
            function isPositionEmpty(pos) {
                if (snake.some(s => s.x === pos.x && s.y === pos.y)) return false;
                if (apples.some(a => a.x === pos.x && a.y === pos.y)) return false;
                if (obstacles.some(o => o.x === pos.x && o.y === pos.y)) return false;
                return true;
            }

            // --- Card Choice Logic ---
            
            function generateBoosterCards() {
                let availableCards = [...cardDatabase];
                let chosenCards = [];
                
                for(let i = 0; i < 3; i++) {
                    if(availableCards.length === 0) break;
                    
                    let randIndex = Math.floor(Math.random() * availableCards.length);
                    chosenCards.push(availableCards[randIndex]);
                    availableCards.splice(randIndex, 1); // Ensure no duplicates
                }
                return chosenCards;
            }
            
            function displayCardChoices() {
                cardOptions.innerHTML = '';
                generatedCards.forEach((card, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card';
                    cardEl.innerHTML = `
                        <h3>${card.title}</h3>
                        <p class="buff">${card.buff}</p>
                        ${card.debuff ? `<p class="debuff">${card.debuff}</p>` : ''}
                    `;
                    cardEl.addEventListener('click', () => selectCard(index));
                    cardOptions.appendChild(cardEl);
                });
            }
            
            function selectCard(index) {
                const card = generatedCards[index];
                card.applyEffect();
                
                // Advance to next round
                roundCounter++;
                currentGridSize += 2; // Grow map
                scoreQuota = Math.floor(scoreQuota * 1.5) + 5; // Increase quota
                
                // Reset buffs that don't carry over
                if (!activeBuffs.hasty) gameSpeed = 100; // Reset speed if Hasty wasn't picked
                activeBuffs.hasty = false; // Hasty only lasts one round
                
                gameState = 'GAME';
                setupLevel(); // This will resize canvas and start new level
            }

            // --- Roguelite Systems (Upgrades & Save/Load) ---

            function getUpgradeCost(level) {
                return Math.floor(10 * Math.pow(1.5, level)); // Exponential cost
            }

            function updateUpgradesUI() {
                upgradeCoins.textContent = persistentState.appleCoins;
                
                // Apple Rate Upgrade
                const appleLevel = persistentState.upgrades.appleSpawnRateLevel;
                const currentAppleRate = BASE_APPLE_SPAWN_RATE + (appleLevel * APPLE_RATE_INCREASE);
                appleRateValue.textContent = `${(currentAppleRate * 100).toFixed(2)}%`;
                appleRateCost.textContent = getUpgradeCost(appleLevel);
                toggleAppleRate.checked = persistentState.activeUpgrades.appleSpawnRate;

                // Start Length Upgrade
                const lengthLevel = persistentState.upgrades.startLengthLevel;
                const currentStartLength = BASE_START_LENGTH + (lengthLevel * START_LENGTH_INCREASE);
                startLengthValue.textContent = currentStartLength;
                startLengthCost.textContent = getUpgradeCost(lengthLevel);
                toggleStartLength.checked = persistentState.activeUpgrades.startLength;
            }

            function buyUpgrade(upgradeName) {
                const level = persistentState.upgrades[upgradeName];
                const cost = getUpgradeCost(level);
                
                if (persistentState.appleCoins >= cost) {
                    persistentState.appleCoins -= cost;
                    persistentState.upgrades[upgradeName]++;
                    saveState();
                    updateUpgradesUI();
                } else {
                    // Not enough coins (could show a message)
                    console.log("Not enough coins!");
                }
            }
            
            function toggleUpgradeActive(upgradeName) {
                persistentState.activeUpgrades[upgradeName] = !persistentState.activeUpgrades[upgradeName];
                saveState();
                updateUpgradesUI();
            }

            function saveState() {
                localStorage.setItem('rogueSnakeState', JSON.stringify(persistentState));
            }

            function loadState() {
                const savedState = localStorage.getItem('rogueSnakeState');
                if (savedState) {
                    persistentState = JSON.parse(savedState);
                    // Ensure new properties are merged if save file is old
                    if (!persistentState.upgrades.startLengthLevel) {
                        persistentState.upgrades.startLengthLevel = 0;
                    }
                    if (persistentState.activeUpgrades.startLength === undefined) {
                        persistentState.activeUpgrades.startLength = true;
                    }
                    if (persistentState.highestRound === undefined) {
                        persistentState.highestRound = 0;
                    }
                }
            }
            
            // --- Start ---
            initializeGame();
        });
    </script>
</body>
</html>